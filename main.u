import "/main_wrapper.u"
import "/stdout.u"
import "/Nordsee/SDL.uh"

pretty_main
{
	var u32 hightmap_size_log2= 8u;
	var u32 highmap_size= 1u << hightmap_size_log2;

	var [ f32, highmap_size * highmap_size ] mut highmap_data= zero_init;

	for( auto mut y= 0u; y < highmap_size; ++y )
	{
		for( auto mut x= 0u; x < highmap_size; ++x )
		{
			var u32 min_octave = 2u;
			var u32 max_octave = 8u;

			var u32 mut r = 0u;
			for(var u32 mut i = min_octave; i <= max_octave; ++i)
			{
				r += InterpolatedNoise(x, y, hightmap_size_log2, i) >> (max_octave  - i);
			}

			// Scale and clamp to water level.
			var f32 h = ust::max(77.0f, f32(r) / 512.0f);

			var u32 address = x + (y << hightmap_size_log2);
			highmap_data[address] = h;
		}
	}

	ust::stdout_print( "Nordsee\n" );

	unsafe( SDL_Init( SDL_INIT_VIDEO ) );

	auto mut window_title_nt= "Nordsee\0";

	auto SDL_WINDOWPOS_CENTERED= 0x2FFF0000;

	var u32 window_width= 640u, window_height= 480u;

	var $(SDL_Window_) window=
		unsafe( SDL_CreateWindow(
			$<(window_title_nt[0]),
			SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED,
			i32(window_width), i32(window_height),
			0u ) );

	var $(SDL_Surface) surface_ptr= unsafe( SDL_GetWindowSurface( window ) );

	if( ust::is_nullptr(surface_ptr) ||
		ust::is_nullptr( unsafe( $>(surface_ptr).format ) ) ||
		i32( unsafe( $>( $>(surface_ptr).format ) ).BytesPerPixel ) != 4 )
	{
		ust::stderr_print( "Invalid window surface!\n" );
		return -1;
	}

	var SDL_Surface& surface= unsafe( $>(surface_ptr) );

	var u32 mut iteration= 0u;

	loop label main_loop
	{
		var SDL_Event mut event= zero_init;
		while( unsafe( SDL_PollEvent( $<(event) ) ) != 0 )
		{
			var SDL_EventType t( i64( event.union_contents[0] ) );
			if( t == SDL_QUIT )
			{
				ust::stdout_print( "Quit event\n" );
				break label main_loop;
			}
			if( t == SDL_WINDOWEVENT )
			{
				auto& windows_event= unsafe( cast_ref_unsafe</SDL_WindowEvent/>( event ) );
				if( SDL_WindowEventID( windows_event.event ) == SDL_WINDOWEVENT_CLOSE )
				{
					ust::stdout_print( "Window close event\n" );
					break label main_loop;
				}
			}
			if( t == SDL_KEYDOWN )
			{
				auto& keyboard_event= unsafe( cast_ref_unsafe</SDL_KeyboardEvent/>( event ) );
				if( keyboard_event.keysym.scancode == SDL_SCANCODE_ESCAPE )
				{
					ust::stdout_print( "Esc pressed\n" );
					break label main_loop;
				}
			}
		}

		var bool must_lock_surface= ( surface.flags & u32(SDL_RLEACCEL) ) != 0u;

		if( must_lock_surface )
		{
			unsafe( SDL_LockSurface( surface_ptr ) );
		}

		type Color32= u32;

		var $(Color32) dst_colors= unsafe( ust::byte_ptr_cast</Color32/>( surface.pixels ) );
		var u32 pitch = u32( surface.pitch ) / u32( typeinfo</Color32/>.size_of );
		for( var u32 mut y= 0u; y < u32( surface.h ); ++y )
		{
			var $(Color32) line_dst= unsafe( dst_colors + y * pitch );
			for( var u32 mut x= 0u; x < u32( surface.w ); ++x )
			{
				unsafe( $>( line_dst + x ) )=
					( x * 255u / window_width ) |
					(( y * 255u / window_height ) << 8u) |
					(((iteration << 1u) & 255u) << 16u);
			}
		}
		++iteration;

		if( must_lock_surface )
		{
			unsafe( SDL_UnlockSurface( surface_ptr ) );
		}

		unsafe( SDL_UpdateWindowSurface( window ) );

		unsafe( SDL_Delay( 16u ) );
	}

	unsafe( SDL_DestroyWindow( window ) );

	return 0;
}

fn InterpolatedNoise(u32 x, u32 y, u32 size_log2, u32 k) : u32
{
	var u32 step = 1u << k;
	var u32 mask = ((1u << size_log2) >> k) - 1u; // This makes noise tileable.

	var u32 X = x >> k;
	var u32 Y = y >> k;

	var [ u32, 4 ] noise
	[
		u32(Noise2(i32((X     ) & mask), i32((Y     ) & mask), 0)),
		u32(Noise2(i32((X + 1u) & mask), i32((Y     ) & mask), 0)),
		u32(Noise2(i32((X + 1u) & mask), i32((Y + 1u) & mask), 0)),
		u32(Noise2(i32((X     ) & mask), i32((Y + 1u) & mask), 0))
	];

	var u32 dx = x - (X << k);
	var u32 dy = y - (Y << k);

	var [ u32, 2 ] interp_x
	[
		dy * noise[3] + (step - dy) * noise[0],
		dy * noise[2] + (step - dy) * noise[1],
	];
	return u32((interp_x[1] * dx + interp_x[0] * (step - dx)) >> (k + k));
}


fn Noise2( i32 x, i32 y, i32 seed) : i32
{
	var i32 X_NOISE_GEN = 1619;
	var i32 Y_NOISE_GEN = 31337;
	var i32 Z_NOISE_GEN = 6971;
	var i32 SEED_NOISE_GEN = 1013;

	var i32 mut n = (
		X_NOISE_GEN * x +
		Y_NOISE_GEN * y +
		Z_NOISE_GEN * 0 +
		SEED_NOISE_GEN * seed)
		& 0x7fffffff;

	n = (n >> 13u) ^ n;
	return ((n * (n * n * 60493 + 19990303) + 1376312589) & 0x7fffffff) >> 15u;
}
