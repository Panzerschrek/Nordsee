import "/main_wrapper.u"
import "/math.u"
import "/stdout.u"
import "/vector.u"
import "/Nordsee/SDL.uh"

pretty_main
{
	var u32 hightmap_size_log2= 10u;
	var u32 hightmap_size= 1u << hightmap_size_log2;
	var u32 hightmap_size_mask= hightmap_size - 1u;

	var ust::vector</TerrainElement/> mut hightmap_data( size_type( hightmap_size * hightmap_size ), TerrainElement{ .height= 0.0f, .color= 0u } );

	for( auto mut y= 0u; y < hightmap_size; ++y )
	{
		for( auto mut x= 0u; x < hightmap_size; ++x )
		{
			var u32 min_octave = 2u;
			var u32 max_octave = 8u;

			var u32 mut r = 0u;
			for(var u32 mut i = min_octave; i <= max_octave; ++i)
			{
				r += InterpolatedNoise(x, y, hightmap_size_log2, i) >> (max_octave  - i);
			}

			// Scale and clamp to water level.
			var f32 h = ust::max(77.0f, f32(r) / 512.0f);

			var u32 address = x + (y << hightmap_size_log2);
			var TerrainElement &mut el= hightmap_data[size_type(address)];
			el.height = h;
		}
	}

	var [ f32, 3 ] sun_dir[ 0.7f, 0.3f, 0.6f ];
	var f32 sun_dir_squared = sun_dir[0] * sun_dir[0] + sun_dir[1] * sun_dir[1] + sun_dir[2] * sun_dir[2];

	for( auto mut y= 0u; y < hightmap_size; ++y )
	{
		for( auto mut x= 0u; x < hightmap_size; ++x )
		{
			var [ [ f32, 3 ], 3 ] mut adjacent_cells = zero_init;
			for(var i32 mut dx = 0; dx < 3; ++dx)
			{
				for(var i32 mut dy = 0; dy < 3; ++dy)
				{
					var u32 address =
						u32((i32(x) + dx - 1) & i32(hightmap_size_mask)) +
						u32(((i32(y) + dy - 1) & i32(hightmap_size_mask)) << hightmap_size_log2);
					adjacent_cells[u32(dx)][u32(dy)] = hightmap_data[size_type(address)].height;
				}
			}

			var f32 dh_dx =
				(adjacent_cells[2][0] + adjacent_cells[2][1] + adjacent_cells[2][2]) -
				(adjacent_cells[0][0] + adjacent_cells[0][1] + adjacent_cells[0][2]);

			var f32 dh_dy =
				(adjacent_cells[0][2] + adjacent_cells[1][2] + adjacent_cells[2][2]) -
				(adjacent_cells[0][0] + adjacent_cells[1][0] + adjacent_cells[2][0]);

			var [ f32, 3 ] normal[ -dh_dx, -dh_dy, 3.0f ];

			var f32 angle_cos =
				(normal[0] * sun_dir[0] + normal[1] * sun_dir[1] + normal[2] * sun_dir[2]) /
				ust::sqrt((normal[0] * normal[0] + normal[1] * normal[1] + normal[2] * normal[2]) * sun_dir_squared);

			var f32 mut sub_dir_dot_clampled = ust::max(0.0f, angle_cos);

			{
				// Trace ray towards the sun up to maximum possible hight.
				var [ f32, 3 ] mut pos[ (x), (y), adjacent_cells[1][1] ];

				while (pos[2] <  256.0f)
				{
					pos[0] += sun_dir[0];
					pos[1] += sun_dir[1];
					pos[2] += sun_dir[2];

					var u32 address =
						u32(i32(ust::floor(pos[0])) & i32(hightmap_size_mask)) +
						u32((i32(ust::floor(pos[1])) & i32(hightmap_size_mask)) << hightmap_size_log2);

					if(pos[2] < hightmap_data[size_type(address)].height)
					{
						// In shadow.
						sub_dir_dot_clampled = 0.0f;
						break;
					}
				}
			}

			var f32 light = 0.3f + 0.69f * sub_dir_dot_clampled;

			var u32 address = x + (y << hightmap_size_log2);
			var TerrainElement &mut el= hightmap_data[size_type(address)];

			var [ f32, 3 ] color= GetTerrainColor( el.height );

			el.color =
				Color32(
					u32(color[0] * light) |
					(u32(color[1] * light) << 8u) |
					(u32(color[2] * light) << 16u) );

		}
	}

	ust::stdout_print( "Nordsee\n" );

	unsafe( SDL_Init( SDL_INIT_VIDEO ) );

	auto mut window_title_nt= "Nordsee\0";

	auto SDL_WINDOWPOS_CENTERED= 0x2FFF0000;

	var u32 window_width= 1024u, window_height= 768u;

	var $(SDL_Window_) window=
		unsafe( SDL_CreateWindow(
			$<(window_title_nt[0]),
			SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED,
			i32(window_width), i32(window_height),
			0u ) );

	var $(SDL_Surface) surface_ptr= unsafe( SDL_GetWindowSurface( window ) );

	if( ust::is_nullptr(surface_ptr) ||
		ust::is_nullptr( unsafe( $>(surface_ptr).format ) ) ||
		i32( unsafe( $>( $>(surface_ptr).format ) ).BytesPerPixel ) != 4 )
	{
		ust::stderr_print( "Invalid window surface!\n" );
		return -1;
	}

	var SDL_Surface& surface= unsafe( $>(surface_ptr) );

	var u64 start_tick= unsafe( SDL_GetPerformanceCounter() );
	var f64 performace_counter_frequency( unsafe( SDL_GetPerformanceFrequency() ) );

	loop label main_loop
	{
		var u64 cur_tick = unsafe( SDL_GetPerformanceCounter() );

		var f32 time( f64(cur_tick - start_tick) / performace_counter_frequency );

		var SDL_Event mut event= zero_init;
		while( unsafe( SDL_PollEvent( $<(event) ) ) != 0 )
		{
			var SDL_EventType t( i64( event.union_contents[0] ) );
			if( t == SDL_QUIT )
			{
				ust::stdout_print( "Quit event\n" );
				break label main_loop;
			}
			if( t == SDL_WINDOWEVENT )
			{
				auto& windows_event= unsafe( cast_ref_unsafe</SDL_WindowEvent/>( event ) );
				if( SDL_WindowEventID( windows_event.event ) == SDL_WINDOWEVENT_CLOSE )
				{
					ust::stdout_print( "Window close event\n" );
					break label main_loop;
				}
			}
			if( t == SDL_KEYDOWN )
			{
				auto& keyboard_event= unsafe( cast_ref_unsafe</SDL_KeyboardEvent/>( event ) );
				if( keyboard_event.keysym.scancode == SDL_SCANCODE_ESCAPE )
				{
					ust::stdout_print( "Esc pressed\n" );
					break label main_loop;
				}
			}
		}

		var bool must_lock_surface= ( surface.flags & u32(SDL_RLEACCEL) ) != 0u;

		if( must_lock_surface )
		{
			unsafe( SDL_LockSurface( surface_ptr ) );
		}

		var $(Color32) dst_colors= unsafe( ust::byte_ptr_cast</Color32/>( surface.pixels ) );
		var u32 pitch = u32( surface.pitch ) / u32( typeinfo</Color32/>.size_of );

		var f32 move_speed = 40.0f;

		var f32 max_depth = f32(hightmap_size) * 1.5f;

		var Color32 c_sky_color= 255u | (225u << 8u) | (215u << 16u);

		var [ f32, 3 ] cam_position[ 0.0f, time * move_speed, 240.0f ];
		var f32 additional_y_shift = 0.7f;

		var f32 screen_scale = 0.5f * f32(ust::max(surface.w, surface.h));

		var f32 cam_angle = time * (-0.06f);
		var f32 cam_angle_cos = ust::cos(cam_angle);
		var f32 cam_angle_sin = ust::sin(cam_angle);

		// Process columns.
		for( var u32 mut x= 0u; x < u32( surface.w ); ++x )
		{
			var f32 ray_x = (f32(x) - f32(surface.w) * 0.5f) / screen_scale;

			var $(Color32) dst_column = unsafe( dst_colors + x );

			var i32 mut prev_y = surface.h;

			for( var f32 mut depth = 30.0f; depth < max_depth; depth *= 1.0035f)
			{
				var [ f32, 2 ] ray_vec[ ray_x * depth, depth ];
				var [ f32, 2 ] ray_vec_rotated[ ray_vec[0] * cam_angle_cos - ray_vec[1] * cam_angle_sin, ray_vec[0] * cam_angle_sin + ray_vec[1] * cam_angle_cos ];
				var [ f32, 2 ] terrain_pos[ ray_vec_rotated[0] + cam_position[0], ray_vec_rotated[1] + cam_position[1] ];

				// Use conversion to int rather than proper floor.
				// It isn't correct for negative numbers, but fine, since we shift camera coordinates to positive values.
				var u32 address =
					u32(i32(ust::floor(terrain_pos[0])) & i32(hightmap_size_mask)) +
					u32((i32(ust::floor(terrain_pos[1])) & i32(hightmap_size_mask)) << hightmap_size_log2);

				var TerrainElement& el = hightmap_data[size_type(address)];

				var f32 screen_y = (el.height - cam_position[2]) / depth;
				var i32 y(((1.0f - additional_y_shift) - screen_y) * screen_scale);

				if(y >= prev_y)
				{
					continue;
				}

				var i32 min_y= ust::max(y, 0);
				for( var i32 mut dst_y = prev_y - 1; dst_y >= min_y; --dst_y)
				{
					unsafe( $>( dst_column + u32(dst_y) * pitch ) ) = el.color;
				}

				prev_y = min_y;
			}

			// Fill remaining sky with fog.
			for(var i32 mut dst_y = prev_y - 1; dst_y >= 0; --dst_y)
			{
				unsafe( $>( dst_column + u32(dst_y) * pitch ) ) = c_sky_color;
			}
		}

		if( must_lock_surface )
		{
			unsafe( SDL_UnlockSurface( surface_ptr ) );
		}

		unsafe( SDL_UpdateWindowSurface( window ) );
	}

	unsafe( SDL_DestroyWindow( window ) );

	unsafe( SDL_Quit() );

	return 0;
}

struct TerrainElement
{
	f32 height;
	Color32 color;
}

type Color32= u32;

fn GetTerrainColor(f32 h) : [ f32, 3 ]
{
	var f32 half_border = 7.0f;

	for( var u32 mut i = 0u; i + 1u < c_num_terrain_colors; ++i)
	{
		if(h <= c_terrain_borders[i])
		{
			var f32 k = ust::min(1.0f, (c_terrain_borders[i] - h) / half_border);
			var f32 one_minus_k = 1.0f - k;
			return ust::make_array(
				c_terrain_colors[i][0] * k + c_terrain_colors[i+1u][0] * one_minus_k,
				c_terrain_colors[i][1] * k + c_terrain_colors[i+1u][1] * one_minus_k,
				c_terrain_colors[i][2] * k + c_terrain_colors[i+1u][2] * one_minus_k );
		}
	}

	return c_terrain_colors[c_num_terrain_colors - 1u];
}

var u32 c_num_terrain_colors = 6u;
var [ f32, c_num_terrain_colors ] c_terrain_borders[ 83.0f, 90.0f, 110.0f, 145.0f, 160.0f, 1000000.0f ];

var [ [ f32, 3 ], c_num_terrain_colors ] c_terrain_colors
[
	[ 200.0f, 120.0f, 110.0f ],
	[ 60.0f, 170.0f, 170.0f ],
	[ 70.0f, 190.0f, 70.0f ],
	[ 80.0f, 128.0f, 80.0f ],
	[ 110.0f, 110.0f, 110.0f ],
	[ 255.0f, 255.0f, 255.0f ],
];

fn InterpolatedNoise(u32 x, u32 y, u32 size_log2, u32 k) : u32
{
	var u32 step = 1u << k;
	var u32 mask = ((1u << size_log2) >> k) - 1u; // This makes noise tileable.

	var u32 X = x >> k;
	var u32 Y = y >> k;

	var [ u32, 4 ] noise
	[
		(Noise2(i32((X     ) & mask), i32((Y     ) & mask), 0)),
		(Noise2(i32((X + 1u) & mask), i32((Y     ) & mask), 0)),
		(Noise2(i32((X + 1u) & mask), i32((Y + 1u) & mask), 0)),
		(Noise2(i32((X     ) & mask), i32((Y + 1u) & mask), 0))
	];

	var u32 dx = x - (X << k);
	var u32 dy = y - (Y << k);

	var [ u32, 2 ] interp_x
	[
		dy * noise[3] + (step - dy) * noise[0],
		dy * noise[2] + (step - dy) * noise[1],
	];
	return u32((interp_x[1] * dx + interp_x[0] * (step - dx)) >> (k + k));
}


fn Noise2( i32 x, i32 y, i32 seed) : i32
{
	var i32 X_NOISE_GEN = 1619;
	var i32 Y_NOISE_GEN = 31337;
	var i32 Z_NOISE_GEN = 6971;
	var i32 SEED_NOISE_GEN = 1013;

	var i32 mut n = (
		X_NOISE_GEN * x +
		Y_NOISE_GEN * y +
		Z_NOISE_GEN * 0 +
		SEED_NOISE_GEN * seed)
		& 0x7fffffff;

	n = (n >> 13u) ^ n;
	return ((n * (n * n * 60493 + 19990303) + 1376312589) & 0x7fffffff) >> 15u;
}
