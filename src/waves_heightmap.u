import "/assert.u"
import "/math.u"
import "/scoped_array.u"
import "fourier_transform.uh"
import "math_constants.uh"
import "waves_heightmap.uh"

namespace NS
{

fn GenerateWavesSpectrum( u32 heightmap_size_log2 ) : ust::vector</Complexf/>
{
	var u32 heightmap_size= 1u << heightmap_size_log2;

	var u32 heightmap_area= heightmap_size * heightmap_size;

	var ust::vector</Complexf/> mut freqs( size_type( heightmap_area ), Complexf::Zero() );

	freqs[ size_type( 2u | ( 3u << heightmap_size_log2 ) ) ]= Complexf( 5.0f, 0.0f );
	freqs[ size_type( 7u | ( 5u << heightmap_size_log2 ) ) ]= Complexf( 2.5f, 0.0f );

	// Frequencies above heightmap_size / 2 represent waves traveling in opposite direction.
	freqs[ size_type( (heightmap_size - 16u ) | ( 16u << heightmap_size_log2 ) ) ]= Complexf( 0.5f, 0.0f );

	return freqs;
}

fn EvaluateWavesSpectrumInTime(
	u32 heightmap_size_log2,
	ust::array_view_imut</Complexf/> in_freqs,
	ust::array_view_mut</Complexf/> out_freqs,
	f32 time )
{
	assert( in_freqs.size() == out_freqs.size() );

	var u32 heightmap_size= 1u << heightmap_size_log2;
	var u32 half_heightmap_size= heightmap_size >> 1u;

	for( var u32 mut y= 0u; y < heightmap_size; ++y )
	{
		for( var u32 mut x= 0u; x < heightmap_size; ++x )
		{
			// TODO - optimize this.


			// See https://en.wikipedia.org/wiki/Gravity_wave
			// omega = sqrt( g * k )
			// g - gravity acceleration, k - wave number

			// TODO - check if we should calculate averaged wave number instead of using supoerpositions.

			// Frequencies above half of the spectrum represent waves traveling backwards.
			var f32 x_corrected= ( x >= half_heightmap_size ? f32( i32(heightmap_size) - i32(x) ) : f32(x) );
			var f32 y_corrected= ( y >= half_heightmap_size ? f32( i32(heightmap_size) - i32(y) ) : f32(y) );

			var f32 mut angular_frequency_x= ust::sqrt( ust::abs( x_corrected ) );
			var f32 mut angular_frequency_y= ust::sqrt( ust::abs( y_corrected ) );

			var Complexf rotation=
				Complexf::ImaginaryExponent( time * ( angular_frequency_x + angular_frequency_y ) );

			var size_type address( x | (y << heightmap_size_log2) );
			out_freqs[ address ]= in_freqs[ address ] * rotation;
		}
	}
}

fn GenerateWavesHeightmap(
	u32 heightmap_size_log2,
	ust::array_view_imut</Complexf/> freqs,
	ust::array_view_mut</f32/> out )
{
	var u32 heightmap_size= 1u << heightmap_size_log2;

	var u32 heightmap_area= heightmap_size * heightmap_size;

	assert( freqs.size() == out.size() )
	assert( freqs.size() == size_type( heightmap_area ) );

	scoped_array Complexf mut intermediate_buffer[ size_type( heightmap_area ) ]( Complexf::Zero() );

	Perform2DInverseFastFourierTransform( heightmap_size_log2, freqs, intermediate_buffer, out );
}

fn GenerateWavesColors(
	u32 heightmap_size_log2,
	ust::array_view_imut</f32/> heightmap_data,
	ust::array_view_mut</Color32/> out )
{
	assert( heightmap_data.size() == out.size() );
	assert( heightmap_data.size() == ( 1s << ( 2u * heightmap_size_log2 ) ) );

	var f32 mut min_height= heightmap_data.front(), mut max_height= min_height;

	foreach( h : heightmap_data )
	{
		ust::min_assign( min_height, h );
		ust::max_assign( max_height, h );
	}

	var f32 height_range= max_height - min_height;

	foreach( pair : heightmap_data.iter().zip( out.iter() ) )
	{
		var f32 intensity= ust::max( 0.0f, ust::min( ( pair.first - min_height ) / height_range, 1.0f ) );
		var u32 intensity_i( intensity * 255.0f );
		pair.second= intensity_i | (intensity_i << 8u) | (intensity_i << 16u);
	}

	var u32 heightmap_size= 1u << heightmap_size_log2;

	var Color32 pink= 0x00FF00FFu;

	for( var u32 mut x= 0u; x < heightmap_size; ++x )
	{
		out[ size_type(x) ]= pink;
	}

	for( var u32 mut y= 0u; y < heightmap_size; ++y )
	{
		out[ size_type( y << heightmap_size_log2 ) ]= pink;
	}
}

} // namespace NS
