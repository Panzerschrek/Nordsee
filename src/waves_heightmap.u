import "/math.u"
import "/scoped_array.u"
import "complex.uh"
import "waves_heightmap.uh"

namespace NS
{

// TODO - move constants to separate file.
// TODO - define PI via TAU instead.
var f32 c_pi= 3.1415926535f;
var f32 c_tau= c_pi * 2.0f;

fn GenerateWavesHeightmap( u32 heightmap_size_log2 ) : ust::vector</f32/>
{
	var u32 heightmap_size= 1u << heightmap_size_log2;

	var ust::vector</f32/> mut heightmap_data( size_type( heightmap_size * heightmap_size ), 0.0f );

	scoped_array f32 mut freqs[ size_type( heightmap_size )]( 0.0f );
	freqs[2s]= 10.0f * f32(heightmap_size);
	freqs[3s]= 6.0f * f32(heightmap_size);
	freqs[8s]= 1.0f * f32(heightmap_size);

	for( auto mut y= 0u; y < heightmap_size; ++y )
	{
		// Perform inverse discrete Fourier transform here.
		var f32 mut h= 0.0f;
		var f32 scale= f32(y) * ( c_tau / f32(heightmap_size) );
		for( auto mut i= 0u; i < heightmap_size; ++i )
		{
			h+= freqs[size_type(i)] * ust::cos( f32(i) * scale );
		}
		h/= f32(heightmap_size);

		for( auto mut x= 0u; x < heightmap_size; ++x )
		{
			var u32 address = x + (y << heightmap_size_log2);
			heightmap_data[size_type(address)] = h;
		}
	}

	return heightmap_data;
}

fn GenerateWavesColors( ust::array_view_imut</f32/> heightmap_data ) : ust::vector</Color32/>
{
	var f32 mut min_height= heightmap_data.front(), mut max_height= min_height;

	foreach( h : heightmap_data )
	{
		ust::min_assign( min_height, h );
		ust::max_assign( max_height, h );
	}

	var f32 height_range= max_height - min_height;

	return ust::make_vector_from_mapped_range(
		heightmap_data,
		lambda[&]( f32 h ) : Color32
		{
			var f32 intensity= ust::max( 0.0f, ust::min( (h - min_height) / height_range, 1.0f ) );
			var u32 intensity_i( intensity * 255.0f );
			return intensity_i | (intensity_i << 8u) | (intensity_i << 16u);
		});
}

} // namespace NS
