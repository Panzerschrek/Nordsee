import "/assert.u"
import "/scoped_array.u"
import "gaussian_complex_random.uh"
import "vec.uh"
import "waves_heightmap.uh"

namespace NS
{

fn GenerateWavesSpectrum( u32 size_log2 ) : ust::vector</Complexf/>
{
	var u32 size= 1u << size_log2;

	var u32 area= size * size;

	var u32 half_size= size >> 1u;

	var ust::vector</Complexf/> mut freqs( size_type( area ), Complexf::Zero() );

	//freqs[ size_type( ( half_size + 2u ) | ( ( half_size + 3u ) << size_log2 ) ) ]= Complexf( 5.0f, 0.0f );
	//freqs[ size_type( ( half_size + 7u ) | ( ( half_size + 5u ) << size_log2 ) ) ]= Complexf( 2.5f, 0.0f );

	// Frequencies below heightmap_size / 2 represent waves traveling in opposite direction.
	//freqs[ size_type( ( half_size - 16u ) | ( ( half_size + 16u ) << size_log2 ) ) ]= Complexf( 0.5f, 0.0f );

	var Vec2f wind_direction= Vec2f( 2.0f, 3.0f ).GetNormalized();

	var f32 max_amplitude_k= 2.0f; // wavenumber of peak waves amplitude.
	var f32 l= 1.0f / max_amplitude_k;

	// A factor used for reducing amplitudes of short waves.
	var f32 cut_amplitude_k= 16.0f;

	// How to scale overall waves.
	var f32 final_amplitudes_scale= 0.5f;

	var PseudoRandomGenerator mut rand_gen;

	for( var u32 mut y= 0u; y < size; ++y )
	{
		for (var u32 mut x= 0u; x < size; ++x )
		{
			var Complexf &mut dst_complex_amplitude= freqs[ size_type( x | (y << size_log2 ) ) ];

			var Vec2f k( f32( i32(x) - i32(half_size) ), f32( i32(y) - i32(half_size) ) );

			var f32 k2= k.SquareLength();
			if( k2 == 0.0f )
			{
				dst_complex_amplitude= Complexf::Zero();
				continue;
			}
			var f32 k4= k2 * k2;

			var f32 dot= k.Dot( wind_direction );
			var f32 dot2= dot * dot;

			// Some sort of Phillips spectrum.
			var f32 power=
				ust::exp( -1.0f / ( k2 * ( l * l ) ) ) * dot2 / k4;

			// A modification of the spectrum to reduce amplitude of short wavelengths.
			var f32 power_corrected=
				power *
				ust::exp( -( k2 / ( cut_amplitude_k * cut_amplitude_k ) ) );

			// Amplitude depends as asquare root on power.
			var f32 amplitude_scale= ust::sqrt( power_corrected ) * final_amplitudes_scale;

			// Sample a random complex number with gaussian distribution to select result amplitude scaler.
			// Real-world waves follow such distribution.
			// Also this gives random phase.
			var Complexf rand_complex_amplitude= GenerateGaussianComplexNumber( rand_gen );

			dst_complex_amplitude= rand_complex_amplitude * amplitude_scale;
		}
	}

	return freqs;
}

fn EvaluateWavesSpectrumInTime(
	u32 heightmap_size_log2,
	ust::array_view_imut</Complexf/> in_freqs,
	ust::array_view_mut</Complexf/> out_freqs,
	f32 time )
{
	assert( in_freqs.size() == out_freqs.size() );

	var u32 heightmap_size= 1u << heightmap_size_log2;
	var u32 half_heightmap_size= heightmap_size >> 1u;

	scoped_array f32 mut wave_numbers_squared[ size_type( heightmap_size ) ]( 0.0f );
	for( auto mut i= 0u; i < heightmap_size; ++i )
	{
		var f32 wave_number= f32( i32(i) - i32( half_heightmap_size ) );
		wave_numbers_squared[ size_type(i) ]= wave_number * wave_number;
	}

	for( var u32 mut y= 0u; y < heightmap_size; ++y )
	{
		var f32 wave_number_squared_y= wave_numbers_squared[ size_type(y) ];

		var size_type start_index( y << heightmap_size_log2 ), end_index( ( y + 1u ) << heightmap_size_log2 );
		auto in_row= in_freqs.subrange( start_index, end_index );
		auto out_row= out_freqs.subrange( start_index, end_index );

		for( var u32 mut x= 0u; x < heightmap_size; ++x )
		{
			var f32 wave_number_squared_x= wave_numbers_squared[ size_type(x) ];

			// Calculate wave number for diagonal waves.
			// This formula results from wave length equation for a wave with given x/y lengths.
			var f32 wave_number= ust::sqrt( wave_number_squared_x + wave_number_squared_y );

			// See https://en.wikipedia.org/wiki/Gravity_wave
			// omega = sqrt( g * k )
			// g - gravity acceleration, k - wave number
			var f32 omega= ust::sqrt( wave_number );

			var Complexf rotation= Complexf::ImaginaryExponent( time * omega );

			out_row[ size_type(x) ]= in_row[ size_type(x) ] * rotation;
		}
	}
}

fn GenerateSideShiftSpectra(
	u32 heightmap_size_log2,
	ust::array_view_imut</Complexf/> in_freqs,
	ust::array_view_mut</Complexf/> out_freqs_x,
	ust::array_view_mut</Complexf/> out_freqs_y )
{
	assert( in_freqs.size() == out_freqs_x.size() );
	assert( in_freqs.size() == out_freqs_y.size() );

	var u32 heightmap_size= 1u << heightmap_size_log2;
	var u32 half_heightmap_size= heightmap_size >> 1u;

	assert( in_freqs.size() == size_type( heightmap_size * heightmap_size ) );

	for( var u32 mut x= 0u; x < heightmap_size; ++x )
	{
		for( var u32 mut y= 0u; y < heightmap_size; ++y )
		{
			var size_type address( x | ( y << heightmap_size_log2 ) );

			var f32 wave_number_x= f32(x) - f32(half_heightmap_size);
			var f32 wave_number_y= f32(y) - f32(half_heightmap_size);

			var f32 squares_sum= wave_number_x * wave_number_x + wave_number_y * wave_number_y;
			if( squares_sum == 0.0f )
			{
				out_freqs_x[address]= Complexf( 0.0f, 0.0f );
				out_freqs_y[address]= Complexf( 0.0f, 0.0f );
				continue;
			}

			var Complexf& in_complex_amplitude= in_freqs[address];

			// TODO - rotate phase, since side motion is 90 degree rotated relative to vertical motion.
			out_freqs_x[address]= in_complex_amplitude * ( f32(heightmap_size) * wave_number_x / squares_sum );
			out_freqs_y[address]= in_complex_amplitude * ( f32(heightmap_size) * wave_number_y / squares_sum );
		}
	}
}

fn GenerateWavesHeightmap(
	u32 heightmap_size_log2,
	ust::array_view_imut</Complexf/> freqs,
	ust::array_view_mut</Complexf/> intermediate_buffer,
	InverseCenteredFFT& fft,
	ust::array_view_mut</f32/> out )
{
	var u32 heightmap_size= 1u << heightmap_size_log2;

	var u32 heightmap_area= heightmap_size * heightmap_size;

	assert( freqs.size() == out.size() )
	assert( freqs.size() == intermediate_buffer.size() );
	assert( freqs.size() == size_type( heightmap_area ) );

	PerformFast2DInverseCenteredFourierTransform( heightmap_size_log2, freqs, intermediate_buffer, fft, out );
}

fn GenerateShiftedHeightmap(
	u32 heightmap_size_log2,
	ust::array_view_imut</f32/> vertical_shift,
	ust::array_view_imut</f32/> shift_x,
	ust::array_view_imut</f32/> shift_y,
	ust::array_view_mut</f32/> out )
{
	var u32 heightmap_size= 1u << heightmap_size_log2;

	var u32 heightmap_area= heightmap_size * heightmap_size;

	assert( vertical_shift.size() == shift_x.size() );
	assert( vertical_shift.size() == shift_y.size() );
	assert( vertical_shift.size() == out.size() );
	assert( vertical_shift.size() == size_type( heightmap_area ) );

	for( auto mut y= 0u; y < heightmap_size; ++y )
	{
		for( auto mut x= 0u; x < heightmap_size; ++x )
		{
			var size_type src_address( x | ( y << heightmap_size_log2 ) );

			// TODO - perform real shift.
			out[ src_address ]= vertical_shift[ src_address ];
		}
	}
}

fn GenerateWavesColors(
	u32 heightmap_size_log2,
	ust::array_view_imut</f32/> heightmap_data,
	ust::array_view_mut</Color32/> out )
{
	assert( heightmap_data.size() == out.size() );
	assert( heightmap_data.size() == ( 1s << ( 2u * heightmap_size_log2 ) ) );

	var f32 mut min_height= heightmap_data.front(), mut max_height= min_height;

	foreach( h : heightmap_data )
	{
		ust::min_assign( min_height, h );
		ust::max_assign( max_height, h );
	}

	var f32 height_range= max_height - min_height;

	foreach( pair : heightmap_data.iter().zip( out.iter() ) )
	{
		var f32 intensity= ust::max( 0.0f, ust::min( ( pair.first - min_height ) / height_range, 1.0f ) );
		var u32 intensity_i( intensity * 255.0f );
		pair.second= intensity_i | (intensity_i << 8u) | (intensity_i << 16u);
	}

	var u32 heightmap_size= 1u << heightmap_size_log2;

	var Color32 red= 0x00FF0000u;
	var Color32 green= 0x0000FF00u;

	for( var u32 mut x= 0u; x < heightmap_size; ++x )
	{
		out[ size_type(x) ]= red;
	}

	for( var u32 mut y= 0u; y < heightmap_size; ++y )
	{
		out[ size_type( y << heightmap_size_log2 ) ]= green;
	}
}

} // namespace NS
