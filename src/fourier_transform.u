import "/assert.u"
import "/scoped_array.u"
import "/vector.u"
import "/string_conversions.u"
import "fourier_transform.uh"
import "math_constants.uh"

namespace NS
{

fn Perform2DInverseFourierTransform(
	u32 size_log2,
	ust::array_view_imut</Complexf/> freqs,
	ust::array_view_mut</Complexf/> intermediate_buffer,
	ust::array_view_mut</f32/> out )
{
	var u32 size= 1u << size_log2;
	var u32 area= size * size;

	assert( freqs.size() == size_type(area) );
	assert( intermediate_buffer.size() == size_type(area) );
	assert( out.size() == size_type(area) );

	// Perform per-row inverse discrete Fourier transform.
	for( auto mut y= 0u; y < size; ++y )
	{
		for( auto mut x= 0u; x < size; ++ x )
		{
			var Complexf mut h= Complexf::Zero();
			var f32 scale= f32(x) * ( c_tau / f32(size) );
			for( auto mut k= 0u; k < size; ++k )
			{
				h+=
					freqs[ size_type( k | ( y << size_log2 ) ) ] *
					Complexf::ImaginaryExponent( f32(k) * scale );
			}
			h/= f32(size);

			intermediate_buffer[ size_type( x | ( y << size_log2 ) ) ]= h;
		}
	}

	// Perform per-column inverse discrete Fourier transform.
	for( auto mut x= 0u; x < size; ++x )
	{
		for( auto mut y= 0u; y < size; ++y )
		{
			var Complexf mut h= Complexf::Zero();
			var f32 scale= f32(y) * ( c_tau / f32(size) );
			for( auto mut k= 0u; k < size; ++k )
			{
				h+=
					intermediate_buffer[ size_type( x | ( k << size_log2 ) ) ] *
					Complexf::ImaginaryExponent( f32(k) * scale );
			}
			h/= f32(size);

			out[ size_type( x | (y << size_log2) ) ] = h.re;
		}
	}
}

fn Perform2DInverseFastFourierTransform(
	u32 size_log2,
	ust::array_view_imut</Complexf/> freqs,
	ust::array_view_mut</Complexf/> intermediate_buffer,
	ust::array_view_mut</f32/> out )
{
	var u32 size= 1u << size_log2;
	var u32 area= size * size;

	assert( freqs.size() == size_type(area) );
	assert( intermediate_buffer.size() == size_type(area) );
	assert( out.size() == size_type(area) );

	// Perform per-row inverse discrete Fourier transform.
	for( auto mut y= 0u; y < size; ++y )
	{
		var size_type start_index( y << size_log2 );
		var size_type end_index= start_index + size_type(size);
		PerformInverseFastFourierTransform(
			freqs.subrange( start_index, end_index ),
			intermediate_buffer.subrange( start_index, end_index ) );
	}

	// Perform per-column inverse discrete Fourier transform.
	for( auto mut x= 0u; x < size; ++x )
	{
		// TODO - perform fast approach too.
		for( auto mut y= 0u; y < size; ++y )
		{
			var Complexf mut h= Complexf::Zero();
			var f32 scale= f32(y) * ( c_tau / f32(size) );
			for( auto mut k= 0u; k < size; ++k )
			{
				h+=
					intermediate_buffer[ size_type( x | ( k << size_log2 ) ) ] *
					Complexf::ImaginaryExponent( f32(k) * scale );
			}
			h/= f32(area);

			out[ size_type( x | (y << size_log2) ) ] = h.re;
		}
	}
}

fn PerformInverseFastFourierTransform(
	ust::array_view_imut</Complexf/> in,
	ust::array_view_mut</Complexf/> out )
{
	assert( in.size() > 0s );
	assert( ( ( in.size() & (in.size() - 1s) ) == 0s ) );
	assert( in.size() == out.size() );

	var size_type mut size_log2= 0s;
	while( ( 1s << size_log2 ) < in.size() )
	{
		++size_log2;
	}

	for( auto mut i= 0s; i < in.size(); ++i )
	{
		// Change bits order in the index.
		auto mut src_index= 0s;
		for( var size_type mut b= 0s; b < size_log2; ++b )
		{
			var size_type bit_value= (i >> (size_log2 - 1s - b)) & 1s;
			src_index |= bit_value << b;
		}

		out[i]= in[src_index];
	}

	for( var size_type mut s= 1s; s <= size_log2; ++s )
	{
		var size_type m= 1s << s;
		var size_type half_m= m >> 1s;

		var f32 scale= c_tau / f32(m);

		for( var size_type mut j= 0s; j < half_m; ++j )
		{
			var Complexf omega= Complexf::ImaginaryExponent( f32(j) * scale );
			for( var size_type mut k= 0s; k < in.size(); k+= m )
			{
				var size_type index0= j + k;
				var size_type index1= j + k + half_m;

				auto val0= out[index0];
				auto val1= out[index1] * omega;

				out[index0]= val0 + val1;
				out[index1]= val0 - val1;
			}
		}
	}
}

} // namespace NS
