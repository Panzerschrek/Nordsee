import "/math.u"
import "/minmax.u"
import "vec.uh"
import "water_heightmap_coloring.uh"

namespace NS
{

fn GenerateWaterHeightmapColors(
	u32 heightmap_size_log2,
	ust::array_view_imut</f32/> heightmap_data,
	ust::array_view_mut</Color32/> out_colors )
{
	var u32 heightmap_size= 1u << heightmap_size_log2;
	var u32 heightmap_size_mask= heightmap_size - 1u;

	var Vec3f sun_dir_normalized= Vec3f( 0.7f, 0.3f, 0.6f ).GetNormalized();

	var Vec3f base_water_color( 68.0f, 129.0f, 179.0f );
	var Vec3f foam_color( 200.0f, 200.0f, 200.0f );

	var Vec3f sun_light_color( 0.6f, 0.6f, 0.5f );
	var Vec3f sky_light_color( 0.4f, 0.4f, 0.5f );

	for( auto mut y= 0u; y < heightmap_size; ++y )
	{
		for( auto mut x= 0u; x < heightmap_size; ++x )
		{
			var [ [ f32, 3 ], 3 ] mut adjacent_cells = zero_init;
			for(var i32 mut dx = 0; dx < 3; ++dx)
			{
				for(var i32 mut dy = 0; dy < 3; ++dy)
				{
					var u32 address =
						u32((i32(x) + dx - 1) & i32(heightmap_size_mask)) +
						u32(((i32(y) + dy - 1) & i32(heightmap_size_mask)) << heightmap_size_log2);
					adjacent_cells[u32(dx)][u32(dy)] = heightmap_data[size_type(address)];
				}
			}

			var f32 dh_dx =
				(adjacent_cells[2][0] + adjacent_cells[2][1] + adjacent_cells[2][2]) -
				(adjacent_cells[0][0] + adjacent_cells[0][1] + adjacent_cells[0][2]);

			var f32 dh_dy =
				(adjacent_cells[0][2] + adjacent_cells[1][2] + adjacent_cells[2][2]) -
				(adjacent_cells[0][0] + adjacent_cells[1][0] + adjacent_cells[2][0]);

			var Vec3f normal= Vec3f( -dh_dx, -dh_dy, 3.0f ).GetNormalized();

			var f32 angle_cos = sun_dir_normalized.Dot( normal );
			var f32 sub_dir_dot_clampled = ust::max(0.0f, angle_cos);

			var f32 peak_factor=
				adjacent_cells[1][1] -
				0.125f * (adjacent_cells[0][0] + adjacent_cells[0][1] + adjacent_cells[0][2] + adjacent_cells[1][0] + adjacent_cells[1][2] + adjacent_cells[2][0] + adjacent_cells[2][1] + adjacent_cells[2][2] );

			var f32 peak_factor_clamped= ust::max( 0.0f, ust::min( peak_factor * 2.0f, 1.0f ) );

			var Vec3f self_color= ( peak_factor_clamped * foam_color + ( 1.0f - peak_factor_clamped ) * base_water_color );

			var Vec3f light_sum= sun_light_color * sub_dir_dot_clampled + sky_light_color;
			var Vec3f result_color= self_color * light_sum;

			var u32 address = x + (y << heightmap_size_log2);

			out_colors[ size_type(address) ] =
				Color32(
					u32( ust::max( 0.0f, ust::min( result_color.z, 255.0f ) ) ) |
					( u32( ust::max( 0.0f, ust::min( result_color.y, 255.0f ) ) ) << 8u) |
					( u32( ust::max( 0.0f, ust::min( result_color.x, 255.0f ) ) ) << 16u) );

		}
	}
}

} // namespace NS
