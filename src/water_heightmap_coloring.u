import "/assert.u"
import "/math.u"
import "/minmax.u"
import "vec.uh"
import "water_heightmap_coloring.uh"

namespace NS
{

fn GenerateWaterHeightmapColors(
	u32 heightmap_size_log2,
	ust::array_view_imut</f32/> heightmap_data,
	ust::array_view_mut</Color32/> out_colors )
{
	assert( heightmap_data.size() == out_colors.size() );
	assert( heightmap_data.size() == ( 1s << ( 2u * heightmap_size_log2 ) ) );

	var u32 heightmap_size= 1u << heightmap_size_log2;
	var u32 heightmap_size_mask= heightmap_size - 1u;

	var Vec3f sun_dir_normalized= Vec3f( 0.7f, 0.3f, 0.4f ).GetNormalized();

	var Vec3f base_water_color( 68.0f, 129.0f, 179.0f );
	var Vec3f water_slopes_color( 80.0f, 129.0f, 100.0f );
	var Vec3f foam_color( 200.0f, 200.0f, 200.0f );

	var Vec3f sun_light_color( 0.7f, 0.7f, 0.6f );
	var Vec3f sky_light_color( 0.4f, 0.4f, 0.5f );

	for( auto mut y= 0u; y < heightmap_size; ++y )
	{
		for( auto mut x= 0u; x < heightmap_size; ++x )
		{
			var [ [ f32, 3 ], 3 ] mut adjacent_cells = zero_init;
			for(var i32 mut dx = 0; dx < 3; ++dx)
			{
				for(var i32 mut dy = 0; dy < 3; ++dy)
				{
					var u32 address =
						u32((i32(x) + dx - 1) & i32(heightmap_size_mask)) +
						u32(((i32(y) + dy - 1) & i32(heightmap_size_mask)) << heightmap_size_log2);
					adjacent_cells[u32(dx)][u32(dy)] = heightmap_data[size_type(address)];
				}
			}

			var f32 dh_dx =
				(adjacent_cells[2][0] + adjacent_cells[2][1] + adjacent_cells[2][2]) -
				(adjacent_cells[0][0] + adjacent_cells[0][1] + adjacent_cells[0][2]);

			var f32 dh_dy =
				(adjacent_cells[0][2] + adjacent_cells[1][2] + adjacent_cells[2][2]) -
				(adjacent_cells[0][0] + adjacent_cells[1][0] + adjacent_cells[2][0]);

			var Vec3f normal= Vec3f( -dh_dx, -dh_dy, 6.0f ).GetNormalized();

			var f32 angle_cos = sun_dir_normalized.Dot( normal );
			var f32 sub_dir_dot_clampled = ust::max(0.0f, angle_cos);

			var f32 slope_factor= 1.0f - normal.z;

			var Vec3f water_color= slope_factor * water_slopes_color + ( 1.0f - slope_factor ) * base_water_color;

			var f32 peak_factor=
				adjacent_cells[1][1] -
				0.125f * (adjacent_cells[0][0] + adjacent_cells[0][1] + adjacent_cells[0][2] + adjacent_cells[1][0] + adjacent_cells[1][2] + adjacent_cells[2][0] + adjacent_cells[2][1] + adjacent_cells[2][2] );

			var f32 peak_factor_clamped= ust::max( 0.0f, ust::min( peak_factor * 2.0f, 1.0f ) );

			var Vec3f color_with_foam= ( peak_factor_clamped * foam_color + ( 1.0f - peak_factor_clamped ) * water_color );

			var Vec3f light_sum= sun_light_color * sub_dir_dot_clampled + sky_light_color;
			var Vec3f result_color= color_with_foam * light_sum;

			var u32 address = x + (y << heightmap_size_log2);

			out_colors[ size_type(address) ] =
				Color32(
					u32( ust::min( result_color.z, 255.0f ) ) |
					( u32( ust::min( result_color.y, 255.0f ) ) << 8u) |
					( u32( ust::min( result_color.x, 255.0f ) ) << 16u) );

		}
	}
}

fn GenerateDebugWavesColors(
	u32 heightmap_size_log2,
	ust::array_view_imut</f32/> heightmap_data,
	ust::array_view_mut</Color32/> out )
{
	assert( heightmap_data.size() == out.size() );
	assert( heightmap_data.size() == ( 1s << ( 2u * heightmap_size_log2 ) ) );

	var f32 mut min_height= heightmap_data.front(), mut max_height= min_height;

	foreach( h : heightmap_data )
	{
		ust::min_assign( min_height, h );
		ust::max_assign( max_height, h );
	}

	var f32 height_range= max_height - min_height;

	foreach( pair : heightmap_data.iter().zip( out.iter() ) )
	{
		var f32 intensity= ust::max( 0.0f, ust::min( ( pair.first - min_height ) / height_range, 1.0f ) );
		var u32 intensity_i( intensity * 255.0f );
		pair.second= intensity_i | (intensity_i << 8u) | (intensity_i << 16u);
	}

	var u32 heightmap_size= 1u << heightmap_size_log2;

	var Color32 red= 0x00FF0000u;
	var Color32 green= 0x0000FF00u;

	for( var u32 mut x= 0u; x < heightmap_size; ++x )
	{
		out[ size_type(x) ]= red;
	}

	for( var u32 mut y= 0u; y < heightmap_size; ++y )
	{
		out[ size_type( y << heightmap_size_log2 ) ]= green;
	}
}

} // namespace NS
