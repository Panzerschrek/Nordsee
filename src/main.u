import "/assert.u"
import "/main_wrapper.u"
import "/math.u"
import "/stdout.u"
import "/vector.u"
import "/Nordsee/SDL.uh"
import "camera_controller.uh"
import "drawable_surface.uh"
import "math_constants.uh"
import "noise_heightmap.uh"
import "performance_counters.uh"
import "text_printer.uh"
import "waves_heightmap_processor.uh"


pretty_main
{
	// Place actual main inside our "NS" namespace.
	return NS::Main();
}

namespace NS
{

fn Main() : i32
{
	ust::stdout_print( "Nordsee\n" );

	var WavesHeightmapProcessor mut waves_heightmap_processor( 8u );

	unsafe( SDL_Init( SDL_INIT_VIDEO ) );

	auto SDL_WINDOWPOS_CENTERED= 0x2FFF0000;

	var u32 window_width= 1024u, window_height= 768u;

	var $(SDL_Window_) window=
		unsafe( SDL_CreateWindow(
			$<( cast_mut( "Nordsee\0"[0] ) ),
			SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED,
			i32(window_width), i32(window_height),
			0u ) );

	if( ust::is_nullptr( window ) )
	{
		ust::stderr_print( "Failed to create window!\n" );
		return -1;
	}

	var $(SDL_Surface) surface_ptr= unsafe( SDL_GetWindowSurface( window ) );

	if( ust::is_nullptr(surface_ptr) ||
		ust::is_nullptr( unsafe( $>(surface_ptr).format ) ) ||
		i32( unsafe( $>( $>(surface_ptr).format ) ).BytesPerPixel ) != 4 )
	{
		ust::stderr_print( "Invalid window surface!\n" );
		return -1;
	}

	var PerformanceCounter mut frame_time_performance_counter;
	var PerformanceCounters mut performance_counters;

	auto mut prev_tick= frame_time_performance_counter.GetCurrentTime();

	var ust::vector</bool/> mut keyboard_state;
	var CameraController mut camera_controller( Vec3f( 0.0f, 0.0f, 180.0f ) );

	loop label main_loop
	{
		auto cur_tick = frame_time_performance_counter.GetCurrentTime();
		var f32 time_delta_s= ust::min( frame_time_performance_counter.CalculateDurationS( prev_tick, cur_tick ), 0.5f );
		frame_time_performance_counter.AddMeasurement( prev_tick, cur_tick );
		prev_tick= cur_tick;

		var SDL_Event mut event= zero_init;
		while( unsafe( SDL_PollEvent( $<(event) ) ) != 0 )
		{
			var SDL_EventType t( i64( event.union_contents[0] ) );
			if( t == SDL_QUIT )
			{
				break label main_loop;
			}
			if( t == SDL_WINDOWEVENT )
			{
				auto& windows_event= unsafe( cast_ref_unsafe</SDL_WindowEvent/>( event ) );
				if( SDL_WindowEventID( windows_event.event ) == SDL_WINDOWEVENT_CLOSE )
				{
					break label main_loop;
				}
			}
			if( t == SDL_KEYDOWN )
			{
				auto& keyboard_event= unsafe( cast_ref_unsafe</SDL_KeyboardEvent/>( event ) );
				if( keyboard_event.keysym.scancode == SDL_SCANCODE_ESCAPE )
				{
					break label main_loop;
				}
			}
		}

		{
			var i32 mut key_count= 0;
			var $(Uint8) keyboard_state_raw= unsafe( SDL_GetKeyboardState( $<( key_count ) ) );

			keyboard_state.resize( size_type( key_count ), false );

			for( auto mut i= 0s; i < size_type(key_count); ++i )
			{
				keyboard_state[i]= unsafe( $>( keyboard_state_raw + i ) ) != Uint8(0);
			}
		}

		camera_controller.Update( time_delta_s, keyboard_state );

		{
			auto &mut sub_countrers= performance_counters.waves_heightmap_processor;
			performance_counters.total_heightmap_generation.RunWithMeasurement(
				lambda[&]()
				{
					waves_heightmap_processor.Update( time_delta_s, sub_countrers );
				} );
		}

		var SDL_Surface& surface= unsafe( $>(surface_ptr) );

		var bool must_lock_surface= ( surface.flags & u32(SDL_RLEACCEL) ) != 0u;

		if( must_lock_surface )
		{
			unsafe( SDL_LockSurface( surface_ptr ) );
		}

		var u32 pitch= u32( surface.pitch ) / u32( typeinfo</Color32/>.size_of );

		var DrawableSurface drawable_surface
		{
			.w( surface.w ),
			.h( surface.h ),
			.pitch= pitch,
			.data= unsafe( ust::array_view_mut</Color32/>(
				ust::byte_ptr_cast</Color32/>( surface.pixels ),
				size_type( pitch * u32(surface.h) ) ) ),
		};

		performance_counters.heightmap_rendering.RunWithMeasurement(
			lambda[&]()
			{
				DrawHeightmap(
				waves_heightmap_processor.GetHeightmapSizeLog2(),
				waves_heightmap_processor.GetHeightmapData(),
				waves_heightmap_processor.GetColorData(),
				camera_controller,
				drawable_surface );
			} );

		DebugDrawSpectrum(
			waves_heightmap_processor.GetHeightmapSizeLog2(),
			waves_heightmap_processor.GetCurrentSpectrum(),
			drawable_surface );

		DrawFPS( drawable_surface, frame_time_performance_counter.GetAverageDurationS() );
		DrawPerformanceCounters( drawable_surface, performance_counters );

		if( must_lock_surface )
		{
			unsafe( SDL_UnlockSurface( surface_ptr ) );
		}

		unsafe( SDL_UpdateWindowSurface( window ) );
	}

	unsafe( SDL_DestroyWindow( window ) );

	unsafe( SDL_Quit() );

	return 0;
}

fn DrawHeightmap(
	u32 heightmap_size_log2,
	ust::array_view_imut</f32/> heightmap_data,
	ust::array_view_imut</Color32/> color_data,
	CameraController& camera_controller,
	DrawableSurface& surface )
{
	var u32 heightmap_size = 1u << heightmap_size_log2;
	var u32 heightmap_size_mask= heightmap_size - 1u;

	var f32 max_depth = 1536.0f;

	var Color32 c_sky_color= 255u | (225u << 8u) | (215u << 16u);

	var Vec3f cam_pos= camera_controller.GetPos();
	var f32 additional_y_shift = -ust::tan( camera_controller.GetElevation() );

	var f32 screen_scale = 0.5f * f32(ust::max(surface.w, surface.h));

	var f32 cam_angle = camera_controller.GetAzimuth();
	var f32 ray_rotate_cos = ust::cos(cam_angle);
	var f32 ray_rotate_sin = ust::sin(cam_angle);

	var f32 constexpr start_depth_base= 2.0f;
	var f32 constexpr depth_power_factor= 1.01f;

	// Offset start depth of each second column by square root of depth power factor.
	// Doing so we can hide artifacts of step-by-step rendering caused by too heigh value of the depth factor.
	var [ f32, 2 ] start_depth
	[
		start_depth_base,
		start_depth_base * ust::sqrt( depth_power_factor ),
	];

	// Process columns.
	// Draw columns in pairs effectively reducing horizontal resolution by 2,
	// since it's too expensive to render each column properly because of poor cache-locality of column-based rendering into a row-based framebuffer.
	var u32 max_column= surface.w - 1u;
	for( var u32 mut column= 0u; column < max_column; column+= 2u )
	{
		var f32 ray_side_offset = (f32(surface.w) * 0.5f - f32(column)) / screen_scale;

		auto dst_column= surface.data.subrange_start( size_type(column) );

		var i32 mut prev_row( surface.h );

		for( var f32 mut depth= start_depth[ (column >> 1u) & 1u ];
			depth < max_depth;
			depth *= depth_power_factor )
		{
			var Vec2f ray_vec( depth, ray_side_offset * depth );
			var Vec2f ray_vec_rotated(
				ray_vec.x * ray_rotate_cos - ray_vec.y * ray_rotate_sin,
				ray_vec.y * ray_rotate_cos + ray_vec.x * ray_rotate_sin );
			var Vec2f terrain_pos= ray_vec_rotated + Vec2f( cam_pos.x, cam_pos.y );

			var u32 address =
				u32(i32(ust::floor(terrain_pos.x)) & i32(heightmap_size_mask)) +
				u32((i32(ust::floor(terrain_pos.y)) & i32(heightmap_size_mask)) << heightmap_size_log2);

			var f32 height = heightmap_data[size_type(address)];

			var f32 screen_row = (height - cam_pos.z) / depth;
			var i32 row(((1.0f - additional_y_shift) - screen_row) * screen_scale);

			if(row >= prev_row)
			{
				continue;
			}

			var Color32 color= color_data[size_type(address)];

			var i32 min_row= ust::max(row, 0);
			for( var i32 mut dst_row = prev_row - 1; dst_row >= min_row; --dst_row)
			{
				var size_type index( u32(dst_row) * surface.pitch );
				dst_column[ index ]= color;
				dst_column[ index + 1s ]= color;
			}

			prev_row = min_row;
		}

		// Fill remaining sky with fog.
		for(var i32 mut dst_row = prev_row - 1; dst_row >= 0; --dst_row)
		{
			var size_type index( u32(dst_row) * surface.pitch );
			dst_column[ index ]= c_sky_color;
			dst_column[ index + 1s ]= c_sky_color;
		}
	}
}

fn DebugDrawSpectrum(
	u32 size_log2,
	ust::array_view_imut</Complexf/> spectrum,
	DrawableSurface& surface )
{
	var u32 size= 1u << size_log2;
	assert( spectrum.size() == size_type( size * size ) );

	var f32 mut max_square_magnitude= 0.0f;
	foreach( &c : spectrum )
	{
		ust::max_assign( max_square_magnitude, c.SquareMagnitude() );
	}

	var Complexf angle_red= Complexf::ImaginaryExponent( c_tau * 0.0f / 3.0f );
	var Complexf angle_green= Complexf::ImaginaryExponent( c_tau * 1.0f / 3.0f );
	var Complexf angle_blue= Complexf::ImaginaryExponent( c_tau * 2.0f / 3.0f );

	var f32 max_magnitude= ust::sqrt( max_square_magnitude );

	for( var u32 mut y= 0u; y < size; ++y )
	{
		auto src_row= spectrum.subrange( size_type( y << size_log2 ), size_type( ( y + 1u ) << size_log2 ) );
		auto dst_row= surface.data.subrange( size_type( y * surface.pitch ), size_type( ( y + 1u ) * surface.pitch ) );

		for( var u32 mut x= 0u; x < size; ++x )
		{
			var Complexf& c= src_row[ size_type(x) ];

			var f32 red_dot= Vec2f( c.re, c.im ).Dot( Vec2f( angle_red.re, angle_red.im ) );
			var f32 green_dot= Vec2f( c.re, c.im ).Dot( Vec2f( angle_green.re, angle_green.im ) );
			var f32 blue_dot= Vec2f( c.re, c.im ).Dot( Vec2f( angle_blue.re, angle_blue.im ) );

			var f32 red_intensity= ust::sqrt( ust::max( 0.0f, red_dot / max_magnitude ) );
			var f32 green_intensity= ust::sqrt( ust::max( 0.0f, green_dot / max_magnitude ) );
			var f32 blue_intensity=  ust::sqrt( ust::max( 0.0f, blue_dot / max_magnitude ) );

			var Color32 color=
				u32( ust::min( blue_intensity, 1.0f ) * 255.0f ) |
				( u32( ust::min( green_intensity, 1.0f ) * 255.0f ) << 8u ) |
				( u32( ust::min( red_intensity, 1.0f ) * 255.0f ) << 16u );
			dst_row[ size_type(x) ]= color;
		}
	}
}

fn DrawFPS( DrawableSurface& surface, f32 frame_duration_s )
{
	auto mut text= "   0.0 fps";
	StringifyValueInFourPointOneFormat( 1.0f / frame_duration_s, text );

	var Color32 color= 0xFFFFFFFFu;

	DrawText( surface, text, i32( surface.w - 84u ), 2, color, 1u );

	var f32 frame_duration_ms= 1000.0f * frame_duration_s;

	auto mut frame_time_text= "   0.0 ms";
	StringifyValueInFourPointOneFormat( frame_duration_ms, frame_time_text );

	DrawText( surface, frame_time_text, i32( surface.w - 76u ), 20, color, 1u );
}

fn DrawPerformanceCounters(
	DrawableSurface& surface,
	PerformanceCounters& counters )
{
	var Color32 color= 0xFFFFFFFFu;

	auto stringify_value_as_milliseconds=
		lambda[]( f32 val, ust::array_view_mut</char8/> pattern )
		{
			var size_type s= pattern.size();
			StringifyValueInFourPointOneFormat( 1000.0f * val, pattern.subrange_start( s - 9s ) );
		};

	auto row_step= 18;
	auto num_rows= 8;
	auto mut y_offset= i32(surface.h) - num_rows * row_step;
	auto mut row= 0;

	{
		auto mut text= "Spectrum in time evaluation:    0.0 ms";
		stringify_value_as_milliseconds( counters.waves_heightmap_processor.spectrum_in_time_evaluation.GetAverageDurationS(), text );
		DrawText( surface, text, 0, y_offset + row * row_step, color, 1u );
		++row;
	}
	{
		auto mut text= "Side shift spectrum calculation:    0.0 ms";
		stringify_value_as_milliseconds( counters.waves_heightmap_processor.side_shift_spectrum_calculation.GetAverageDurationS(), text );
		DrawText( surface, text, 0, y_offset + row * row_step, color, 1u );
		++row;
	}
	{
		auto mut text= "Heightmap generation:    0.0 ms";
		stringify_value_as_milliseconds( counters.waves_heightmap_processor.heightmap_generation.GetAverageDurationS(), text );
		DrawText( surface, text, 0, y_offset + row * row_step, color, 1u );
		++row;
	}
	{
		auto mut text= "Heightmap side shifts calculation:    0.0 ms";
		stringify_value_as_milliseconds( counters.waves_heightmap_processor.heightmap_side_shifts_calculation.GetAverageDurationS(), text );
		DrawText( surface, text, 0, y_offset + row * row_step, color, 1u );
		++row;
	}
	{
		auto mut text= "Heightmap side shifting:    0.0 ms";
		stringify_value_as_milliseconds( counters.waves_heightmap_processor.heightmap_side_shifting.GetAverageDurationS(), text );
		DrawText( surface, text, 0, y_offset + row * row_step, color, 1u );
		++row;
	}
	{
		auto mut text= "Colors generation:    0.0 ms";
		stringify_value_as_milliseconds( counters.waves_heightmap_processor.colors_generation.GetAverageDurationS(), text );
		DrawText( surface, text, 0, y_offset + row * row_step, color, 1u );
		++row;
	}
	{
		auto mut text= "Total heightmap generation:    0.0 ms";
		stringify_value_as_milliseconds( counters.total_heightmap_generation.GetAverageDurationS(), text );
		DrawText( surface, text, 0, y_offset + row * row_step, color, 1u );
		++row;
	}
	{
		auto mut text= "Heightmap rendering:    0.0 ms";
		stringify_value_as_milliseconds( counters.heightmap_rendering.GetAverageDurationS(), text );
		DrawText( surface, text, 0, y_offset + row * row_step, color, 1u );
		++row;
	}
}

fn StringifyValueInFourPointOneFormat( f32 val, ust::array_view_mut</char8/> text )
{
	var u32 val_int( val );

	if( val_int >= 1000u )
	{
		text[0s]= char8( u32('0') + val_int / 1000u );
	}
	if( val_int >= 100u )
	{
		text[1s]= char8( u32('0') + val_int / 100u % 10u );
	}
	if( val_int >= 10u )
	{
		text[2s]= char8( u32('0') + val_int / 10u % 10u );
	}
	text[3s]= char8( u32('0') + val_int % 10u );
	text[5s]= char8( u32('0') + u32(val * 10.0f ) % 10u );
}

} // namespace NS
